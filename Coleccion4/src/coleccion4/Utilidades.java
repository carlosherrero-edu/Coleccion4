package coleccion4;

/**
* Tipo enumerado con los posibles cuadrantes o ejesen que se encuentra un punto en el plano
* 
*/
enum Cuadrantes {
	PRIMERO,
	SEGUNDO,
	TERCERO, 
	CUARTO,
	EJE_HORIZONTAL,
	EJE_VERTICAL,
	ORIGEN
};


/**
 * Utilidades para los ejercicios de la Colecci√≥n 4.
 * Clase compuesta de funciones - m√©todos est√°ticos- que se invocar√°n desde otras clases
 * @author Carlos Herrero
 * @version 27-dic-2020
 */



public class Utilidades {
	
	/**
	 * Funci√≥n que determina si un n√∫mero entero es par o impar
	 * Corresponde a soluci√≥n del ejercicio 6 de la colecci√≥n 3
	 * @param numero valor entero
	 * @return cadena que indica si es par o impar
	 */
	public static String dimeParidad ( int numero  ) {
		
		String resultado;
		
		if (numero % 2 == 0) {
			resultado = "PAR";
		} else {
			resultado = "IMPAR";
		}
		return resultado;		
		
	}
	
	
	/**
	 * M√©todo para convertir una temperatura de grados Celsius a Faretheim
	 * corresponde a ejercicio 2 de la colecci√≥n 3
	 * @param tempCelsius valor decimal de la temperatura en Celsius
	 * @return valor decimal con la temperatura equivalente en Faretheim
	 */
	public static double celsiusAFaretheim (double tempCelsius ) {
		//soluci√≥n de Adri√°n Navarro
		double fahrenheit = (tempCelsius * 9 / 5) + 32;
        return fahrenheit;
	}
	
	/**
	 * M√©todo para calcular el preio de un art√≠culo despu√©s de aplicar un porcentaje de descuento
	 * corresponde a ejercicio 5 de la colecci√≥n 3
	 * @param precioInicial precio del art√≠culo antes de aplicar el descuento
	 * @param porcRebaja porcentaje de descuento, entre 0 y 100
	 * @return precio del art√≠culo una vez aplicado el porcentaje de descuento
	 */
	public static double calcularPrecioRebajado (double precioInicial, double porcRebaja ) {
		//soluci√≥n de Adri√°n Navarro
		double precioFinal;
        precioFinal=  precioInicial * (1 - porcRebaja /100.0);
        return precioFinal;
	}
	
	
	
	/**
	 * M√©todo que devuelve un saludo seg√∫n la hora del d√≠a
	 * corresponde a ejercicio 7 de la colecci√≥n 3
	 * @param hora entero con el valor de la hora entre 0 y 23
	 * @return cadena con el saludo dependiendo de la hora
	 */
	public static String saludarSegunHora (int hora) {
		
		String saludo;			
			//soluci√≥n de Jorge Alvarez
	        if (hora >= 6 && hora < 12) {
	            saludo = "Buenos d√≠as ";
	        } else {
	            if (hora >= 12 && hora < 20)
	            {
	            	saludo = "Buenas tardes ";
	            }
	
	            else {
	            	saludo = "Buenas noches ";
	                
	            }
	        }
		
        
        return saludo;

    }//Fin del m√©todo
	
	/**
	 * Conversor de temperaturas entre las escalas Celsius y Faretheim
	 * corresponde a ejercicio 8 de la colecci√≥n 3
	 * @param temperatura valor de la temperatura de entrada, a convertir
	 * @param escala car√°cter que indica la escala de la temperatura de entrada: 'C' /'F'
	 * @return valor de la temperatura en la otra escala
	 */
	public static double conversorTemperaturas (double temperatura, char escala ) {
		//soluci√≥n de Miguel Rodr√≠guez
		double tempFinal = 0;
        
        if (escala == 'C' || escala == 'c' ) {
            tempFinal = 32 + 9 * (temperatura / 5);
        }
        else if(escala == 'F'|| escala == 'f' ) {
            tempFinal = (temperatura - 32) * 5 / 9;
        }
        
        return tempFinal;
	}
	

		/**
		 * M√©todo para calcular el salario bonificado que se percibe seg√∫n el importe de un salario inicial
		 * corresponde a ejercicio 10 de la colecci√≥n 3
		 * @param salarioInicial importe del salario antes de aplicar la bonificaci√≥n
		 * @return importe del salario una vez aplicada la bonificaci√≥n
		 */
		/**
		 * @param salarioInicial
		 * @return
		 */
		public static double calcularSalarioBonificado(double salarioInicial ) {
			//soluci√≥n de Jonnhie Herrera
			double bonificacion ;
	        
	        if (salarioInicial <= 1000) {
	            bonificacion = 1.2;
	        }
	        else if (salarioInicial <= 1800) {
	            bonificacion = 1.15;
	        }
	        else {
	            bonificacion = 1.10;
	        }
	        
	        double salarioFinal = (salarioInicial*bonificacion);
	        return (salarioFinal);
	}
		
		//corresponde a ejercicio 11 de la colecci√≥n 3
		public static double conversorTemperaturas2 (double temperatura, char escala ) {
				return 0;
		}
		
		public static boolean validarEscalaTemperatura (char escala) {
			 boolean esValido = false;
		        if (escala == 'C' || escala == 'c' || escala == 'F' || escala == 'f' ) {
		            esValido = true;
		        }
		        return esValido;
		}
		

		 /**
		  * M√©todo para devolver el importe literal de un billete de euros
		  * corresponde a ejercicio 12 de la colecci√≥n 3
		  * corresponde a ejercicio 12 de la colecci√≥n 3
		 * @param importeBillete entero con el valor del billete
		 * @return cadena con el valor del billete en letra
		 */
		public static String devolverImporteLiteral (int importeBillete) {
             
	            String resultado = switch (importeBillete){
	            
	                    case 5 -> 
	                            { yield "Cinco euros"; }
	                    case 10 -> 
	                            { yield "Diez euros"; }
	                    case 20 -> 
	                            { yield "Veinte euros"; }
	                    case 50 -> 
                        		{ yield "Cincuenta euros"; }
	                    case 100 -> 
	                            { yield "Cien euros"; }
	                    case 200 -> 
	                            { yield "Doscientos euros"; }
	                    case 500 -> 
	                            { yield "Quinientos euros"; }                 
	                    default ->
	                            { yield  "Ese billete no existe" ; }
	                    } ;
	                    
	            return resultado ;
	        }
		

		/**
		 * M√©todo que devuelve el n√∫mero mayor de entre 2 n√∫meros de entrada
		 * corresponde a ejercicio 13 de la colecci√≥n 3
		 * @param num1 primer n√∫mero
		 * @param num2 segundo n√∫mero
		 * @return valor del n√∫mero mayor
		 */
		public static double devolverMayor (double num1, double num2 ) {
			
			double numeroMayor;
			
			if (num1> num2) {
				numeroMayor = num1;
			} else {
				numeroMayor = num2;
			}
			
			//   numeroMayor= (num1>num2 ? num1 : num2)  //con condicional ternario 
			
			return numeroMayor;
			
			
		}
		
		/**
		 * M√©todo que devuelve el n√∫mero mayor de entre 3 n√∫meros de entrada
		 * corresponde a ejercicio 13 de la colecci√≥n 3
		 * @param num1 primer n√∫mero
		 * @param num2 segundo n√∫mero
		 * @param num3 tercer n√∫mero
		 * @return valor del n√∫mero mayor de entre los tres
		 */
		public static double devolverMayor (double num1, double num2, double num3 ) {
			double numeroMayor;
			
			numeroMayor = num1;    //inicialmente suponemos que el n√∫mero m√°s grande es el primero
			
			if (num2 > numeroMayor) {   //comparo con el segundo n√∫mero
				numeroMayor = num2; 
			}
			
			if (num3 > numeroMayor) {   //comparo con el tercer n√∫mero
				numeroMayor = num3; 
			}
			
			return numeroMayor;
			
			
		}
		
		/**
		 * M√©todo que devuelve el n√∫mero mayor de entre cuatro n√∫meros de entrada
		 * corresponde a ejercicio 13 de la colecci√≥n 3
		 * @param num1 primer n√∫mero
		 * @param num2 segundo n√∫mero
		 * @param num3 tercer n√∫mero
		 * @param num4 cuarto n√∫mero
		 * @return valor del n√∫mero mayor de entre los cuatro
		 */
		public static double devolverMayor (double num1, double num2, double num3, double num4 ) {
			double numeroMayor;
			
			numeroMayor = num1;    //inicialmente suponemos que el n√∫mero m√°s grande es el primero
			
			if (num2 > numeroMayor) {   //comparo con el segundo n√∫mero
				numeroMayor = num2; 
			}
			
			if (num3 > numeroMayor) {   //comparo con el tercer n√∫mero
				numeroMayor = num3; 
			}
			
			if (num4 > numeroMayor) {   //comparo con el cuarto n√∫mero
				numeroMayor = num4; 
			}
			
			return numeroMayor;
						
		} //fin del m√©todo
		

	/**
	 * Funci√≥n que cuenta el n√∫mero de vocales presentes en una frase del alfabeto ingl√©s
	 * corresponde a ejercicio 19 de la colecci√≥n 3
	 * @param frase Cadena con la frase de entrada
	 * @return  n√∫mero de vocales presentes en la frase
	 */
	public static int contarVocales(String frase) {
		int vocales=0;
		char letra;
		//obtenemos una frase mejorada eliminando espacios y convirtiendo todo a may√∫sculas
		String frase_mayus= frase.trim().toUpperCase();
		//vamos recorriendo la frase mejorada y extrayendo cada car√°cter
		for (int i=0; i<frase_mayus.length(); i++) {
			letra = frase_mayus.charAt(i);
			if (letra=='A' ||letra=='E' ||letra=='I' ||letra=='O' ||letra=='U' ) {
				vocales++;			
			}
			
		}//fin del recorrido de la frase
		
		return vocales;
	}
	
	
	/**
	 * Funci√≥n que determina si un aÒo es o no bisiesto
	 * corresponde a ejercicio 20 de la colecci√≥n 3
	 * @param aÒo valor del aÒo que comprobamos
	 * @return true si el aÒo es bisiesto, false en caso contrario
	 */
	public static boolean esAÒoBisiesto (int aÒo) {
		
		boolean resultado = false;
		
		if (aÒo%400 ==0) {
			resultado = true;
		
		} else {
			if (aÒo%4 ==0 && aÒo%100 !=0) {
				resultado = true;
			} 
		} 
		// en cualquier otro caso, no es bisiesto
		return resultado;
	}
	
	/**
	 * Funci√≥n que comprueba si un tri√°ngulo es v√°lido a partir de las longitudes de sus tres lados.
	 * Se verifica si las longitudes son positivas y si cumplen las condiciones de desigualdad para formar un tri√°ngulo
	 * Corresponde al ejercicio 3.1 de la colecci√≥n 4
	 * @param ladoA longitud del primer lado
	 * @param ladoB longitud del segundo lado
	 * @param ladoC longitud del tercer lado
	 * @return true si cumple las condiciones para ser tri√°ngulo v√°lido, false en otro caso
	 */
	public static boolean esTrianguloValido (double ladoA, double ladoB, double ladoC) {
		
		boolean resultado = false;
		
		//comprobamos una a una todas las condiciones  de validaci√≥n en una estructura condicional anidada
		if (ladoA >0 && ladoB >0 && ladoC >0) {      //1¬™ condici√≥n: lados positivos
			if (ladoA + ladoB > ladoC) {   //2¬™ condici√≥n: la suma de cada par de lados es mayor que el tercer lado
				if (ladoB + ladoC > ladoA) {
					if (ladoA + ladoC > ladoB) {
						//s√≥lo si llegamos hasta aqu√≠ el tri√°ngulo es v√°lido
						resultado=true;
					}
				}
			}
		} //si falla cualquiera de las condiciones anteriores, no es tri√°ngulo v√°lido
		
		return resultado;
	}
	
	
	/**
	 * Funci√≥n que determina el cuadrante o eje al que pertenece un punto en el plano
	 * Corresponde al ejercicio 3.2 de la colecci√≥n 4
	 * @param posX valor de la coordenada horizontal del punto
	 * @param posY valor de la coordenada vertical del punto
	 * @return elemento de la enumeraci√≥n Cuadrantes con el cuadrante o eje al que pertenece
	 */
	public static Cuadrantes dameCuadrante (double posX, double posY) {
		Cuadrantes resultado;
		
		// la comparaci√≥n se efect√∫a mediante condicionales anidados, pero puede quedar m√°s claro si se usan if /else if/else if...
		if (posX > 0 && posY>0) {
			resultado = Cuadrantes.PRIMERO;
		} else {
			if (posX < 0 && posY>0) {
				resultado = Cuadrantes.SEGUNDO;
			} else {
				if (posX < 0 && posY< 0) {
					resultado = Cuadrantes.TERCERO;
					
				} else {
					if (posX > 0 && posY< 0) {
						resultado = Cuadrantes.CUARTO;
					} else {
						if (posX != 0) {
							resultado= Cuadrantes.EJE_HORIZONTAL;
							
						} else {
							if (posY !=0) {
								resultado = Cuadrantes.EJE_VERTICAL;
							} else {
								resultado = Cuadrantes.ORIGEN;
							}
						}
					}
					
				}
			}
		} //fin de toda la estructura condicional anidada
			
		return resultado;
		
	} //fin del m√©todo
	
	/**
	 * Funci√≥n para la validaci√≥n de una fecha de la que se pasan el aÒo, mes y d√≠a
	 * Es soluci√≥n del ejercicio 3.3. de la colecci√≥n 4
	 * @param aÒo Valor del aÒo, que debe estar comprendido entre 1 y 9999
	 * @param mes entero con el valor del mes, que debe estar comprendido entre 1 y 12
	 * @param dia entero con el valor del d√≠a, entre 1 y el √∫ltimo d√≠a del mes
	 * @return true si la fecha existe y es v√°ida, false en otro caso
	 * @see Utilidades.esAÒoBisiesto
	 */
	public static boolean validarFecha (int aÒo, int mes, int dia) {
		
		boolean esValida = false;
		int diaMaximo;
		
		if (aÒo >0 && aÒo <= 9999) {        //valido el aÒo
			//si el aÒo es v√°lido, comprobamos el mes 
			if (mes>=1 && mes <=12) {  //valido el mes
				//si el aÒo y mes son v√°lidos, determinamos el √∫ltimo d√≠a del mes 
					diaMaximo = switch (mes) {
								case 4, 6, 9, 11 -> 
									{ yield 30; }
									
								case 2 -> {
									//tratamiento espec√≠fico para el mes de febrero
									if (Utilidades.esAÒoBisiesto(aÒo)) {
										{yield 29;}
										
									} else {
										{yield 28;}
									}
								}
								
								default ->
									{yield 31;}
								
					};  //fin del switch
				if (dia>=1 && dia <= diaMaximo) {
					//si llego hasta aqu√≠, la fecha es v√°lida
					esValida = true;
				}
			}
		}
		// en cualquier otro caso, la fecha no es v√°lida
		
		return esValida;
	}
	
	
	/**
	 * Funci√≥n que calcula el factorial de un n√∫mero entero
	 * Corresponde a la soluci√≥n del Ejercicio 3.4 de la colecci√≥n 4
	 * @param num entero del que queremos calcular el factorial, suponemos que no negativo
	 * @return entero largo con el valor del factorial del n√∫mero
	 */
	public static long calcularFactorial (int num) {
		
		long producto = 1L; //acumulador para el producto de los n√∫meros sucesivos
		
		if (num >0) {
			for (int i=1; i<=num; i++) {
				producto *= i;
			}
		} //en otro caso, devolver√° 1
		
		return producto;
	}
	
	
	
	/**
	 * M√©todo para detectar el n√∫mero m√°s pequeÒo de una lista
	 * @param lista  lista de tamaÒo variable con n√∫meros decimales
	 * @return valor del n√∫mero m√°s pequeÒo de la lista
	 * Si la lista est√° vac√≠a, devolv√©r√° el valor Double.NaN, que trataremos como error
	 */
	public static double   calcularMenor ( double ... lista) {
		
		double masPequeÒo;
		
		//compruebo al principio si la lista est√° vac√≠a
		if (lista.length ==0) {
			masPequeÒo = Double.NaN;
		} else {
				//la lista tiene alg√∫n elemento
				masPequeÒo= Double.MAX_VALUE;
				//el n√∫mero decimal mayor posible que almacena JAva
				
				for ( double elemento : lista) {  //recorro la lista
					 if (masPequeÒo > elemento) {
			                masPequeÒo = elemento;
			            }
					
				}
		}
		
		return masPequeÒo;
		
	} //fin del m√©todo
	
	

	/**
	 * M√©todo para detectar el n√∫mero m√°s grande de una lista
	 * @param lista  lista de tamaÒo variable con n√∫meros decimales
	 * @return valor del n√∫mero m√°s grande de la lista
	 * Si la lista est√° vac√≠a, devolv√©r√° el valor Double.NaA, que trataremos como error
	 */
	public static double   calcularMayor ( double ... lista) {
		
		double masGrande;
		
		//compruebo al principio si la lista est√° vac√≠a
				if (lista.length ==0) {
					masGrande = Double.NaN;
				} else {
						//la lista tiene alg√∫n elemento
						masGrande= Double.MIN_VALUE;
						//el n√∫mero decimal m√°s pequeÒo posible que almacena JAva
						
						for ( double elemento : lista) {  //recorro la lista
							 if (masGrande <  elemento) {
					                masGrande = elemento;
					            }
							
						}
				}
		
		return masGrande;
		
	} //fin del m√©todo
	
	
	
//	public static double   calcularMenor ( String ... lista) {
//			
//			double masPequeÒo;
//			double numero;
//			
//			//compruebo al principio si la lista est√° vac√≠a
//			if (lista.length ==0) {
//				masPequeÒo = Double.NaN;
//			} else {
//					//la lista tiene alg√∫n elemento
//					masPequeÒo= Double.MAX_VALUE;
//					//el n√∫mero decimal mayor posible que almacena JAva
//					
//					for ( String elemento : lista) {  //recorro la lista
//						//transformo el elmento en decimal
//						numero = Double.parseDouble(elemento);
//						 if (masPequeÒo > numero) {
//				                masPequeÒo = numero;
//				            }
//						
//					}
//			}
//			
//			return masPequeÒo;
//			
//		} //fin del m√©todo
	
	
	/**
	 * M√©todo para calcular la media aritm√©tica de una lista de n√∫meros
	 * @param lista  lista de tamaÒo variable con n√∫meros decimales
	 * @return valor de la media aritm√©tica de los valores de la lista
	 * Si la lista est√° vac√≠a, devolv√©r√° el valor Double.NaA, que trataremos como error
	 */
	public static double calcularMedia (double... lista) {
        //si la lista est√° vac√≠a , lenght ser√° 0 y Java devuelve NaN
		
		double suma = 0;
		
        for (double elemento : lista) {
            suma += elemento;
        }
    
        return (suma/lista.length);
    }
	

	/**
	 * Funci√≥n que dibuja un rect√°ngulo en consola  a base de un car√°cter especial , por defecto el asterisco
	 * Corresponde al ejercicio 3.8 de la colecci√≥n 4
	 * @param num1 entero con la 1¬∫ dimensi√≥n del rect√°ngulo, debe ser >0
	 * @param num2 entero con la 2¬™ dimensi√≥n del rect√°ngulo, debe ser >0
	 * La funci√≥n dibuja el rect√°ngulo pedido, o muestra error si las dimensiones no son correctas
	 */
	public static void dibujaRectangulo (int num1, int num2) {
		
		int base, altura;
		char forma='*';      //caracter base para dibujar el rect√°ngulo
		
		if (num1>0 && num2>0 ) {
			//ordenamos la base y la altura, para que la primera sea mayor
			if (num1 >=num2) {
				base = num1;
				altura= num2;
			} else {
				base = num2;
				altura= num1;
			}
			
			for (int i=0; i<altura; i++) {
				System.out.println();    //imprimimos un salto de l√≠nea entre filas
				for (int j=0; j<=base; j++) {
					//se dibuja el caracter seguido de un espacio
					System.out.format("%s ", forma);   
				}		
			} //fin del bucle exterior
			
			
		} else {
			//si las dimensiones introducidas no son correctas, mostramos un mensaje de error
			System.out.println(" No se puede dibujar el rect√°ngulo");
		}
	} //fin del m√©todo
	

	/**
	 * Funci√≥n que dibuja un tri√°ngulo en consola  a base de un car√°cter especial , por defecto el asterisco
	 * Corresponde al ejercicio 3.9, parte 1 de la Colecci√≥n 4
	 * El tri√°ngulo consta del n√∫mero de filas pasado; cada fila tiene un asterisco menos que la superior
	 * @param num1 entero con el n√∫mero de filas del tri√°ngulo, debe estar comprendido entre 2 y 19
	 * La funci√≥n dibuja el tri√°ngulo pedido, o muestra error si las dimensiones no son correctas
	 */
public static void dibujaTriangulo (int num) {
		
	
		char forma='*';   //caracter base para dibujar el rect√°ngulo
		
		if (num >1 && num<20) {
			//cada fila consta de un asterisco menos, empezando por el valor de "num"
			for (int i=num; i>0; i--) {
				System.out.println();   //salto de l√≠nea entre fila y fila
				for (int j=1; j<=i; j++) {
					System.out.format("%s ", forma);  //se dibuja el caracter seguido de un espacio
				}			
			}
					
		} else {
			//el n√∫mero introducido no cumple las condiciones de validaci√≥n
			System.out.println(" No se puede dibujar el tri√°ngulo");
		}
	}//fin del m√©todo


/**
 * Funci√≥n que dibuja un tri√°ngulo en consola  a base de un car√°cter especial , por defecto el asterisco
 * Corresponde al ejercicio 3.9, parte 2 de la Colecci√≥n 4
 * En este tri√°ngulo, cada fila lleva 2 elementos menos que la anterior, de forma que queden centrados
 * @param num1 entero con el n√∫mero de elementos de la fila inicial o superior , debe estar comprendido entre 2 y 49, y ser impar
 * La funci√≥n dibuja el tri√°ngulo pedido, o muestra error si las dimensiones no son correctas
 */
public static void dibujaTriangulo2 (int num) {
	
	
		char forma='*'; //caracter base para dibujar el rect√°ngulo
		int huecos;
		
		if (num >1 && num<50 && num%2 != 0) {
			
			for (int i=num; i>0; i-=2) {  
				//cada fila lleva 2 asteriscos menos que la anterior,empezando por el valor de num
				System.out.println(); //salto de l√≠nea inicial
				//n√∫mero de huecos que debemos dejar al principio o al final de cada fila de asteriscos
				huecos = (num-i)/2;    
				
				for (int j=1; j<=num; j++) {
					if (j<= huecos || j> i+huecos) {
						System.out.print("  "); //dibujamos un hueco seguido de un espacio
					} else {
						System.out.format("%s ", forma); //dibujamos un car√°cter seguido de un espacio
					}				
				}				
			} //fin del bucle externo
					
		} else {
			//el valor de entrada no cumple las condiciones de validaci√≥n
			System.out.println(" No se puede dibujar el tri√°ngulo");
		}
	}

	
}
	
	


